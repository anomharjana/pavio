<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Dotmap CSV Indonesia</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>

<body class="bg-gray-100 flex flex-col items-center">
  <div class="container max-w-4xl w-full p-6 mt-10 bg-white shadow-lg rounded-lg">
    <h2 class="text-2xl text-center font-semibold text-gray-800 mb-4">Upload CSV dan Tampilkan Dotmap (Peta Kasus)</h2>

    <input type="file" id="csvFile" accept=".csv" class="px-4 py-2 border rounded-lg mb-4 w-full bg-gray-100" />
    <button id="showMapBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 w-full" disabled>Tampilkan Titik</button>
    <div id="status" class="mt-3 text-gray-600">Silakan upload file CSV berisi latitude & longitude.</div>

    <div id="interpretationSection" class="mt-6 hidden">
      <h3 class="text-xl font-semibold text-gray-700">Pilih Variabel untuk Interpretasi:</h3>
      <select id="columnSelect" class="mt-2 px-4 py-2 border rounded-lg bg-gray-100 w-full">
        <option value="" disabled selected>Pilih Kolom untuk Interpretasi</option>
      </select>
      <div id="summary" class="mt-4 text-gray-700"></div>
      <div id="interpretation" class="mb-4 text-sm bg-blue-50 p-4 rounded"></div>
    </div>

    <div id="map" class="mt-6 rounded-lg border" style="height: 400px;"></div>
  </div>

  <script>
    const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap'
    });
    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles © Esri'
    });

    const map = L.map('map', {
      center: [-2.5, 118],
      zoom: 5,
      layers: [osmLayer]
    });
    const baseMaps = {
      "OpenStreetMap": osmLayer,
      "Satellite": satelliteLayer
    };
    L.control.layers(baseMaps).addTo(map);

    let parsedData = [];
    let latKey, lonKey;
    let selectedColumn;
    let legendControl;

    function detectLatLonFields(headers) {
      const latCandidates = ['lat', 'latitude', 'Latitude', 'LAT'];
      const lonCandidates = ['lon', 'lng', 'long', 'longitude', 'Longitude', 'LON', 'LNG'];
      let lat = null, lon = null;

      for (const key of headers) {
        const lower = key.toLowerCase();
        if (!lat && latCandidates.includes(lower)) lat = key;
        if (!lon && lonCandidates.includes(lower)) lon = key;
      }
      return { latKey: lat, lonKey: lon };
    }

    function analyzeColumn(data, column) {
      const values = data.map(row => row[column]);
      const isNumeric = values.every(value => !isNaN(value));
      if (isNumeric) {
        const numericValues = values.map(Number);
        const min = Math.min(...numericValues);
        const max = Math.max(...numericValues);
        const mean = (numericValues.reduce((acc, val) => acc + val, 0) / numericValues.length).toFixed(2);
        return `Min: ${min}, Max: ${max}, Rata-rata: ${mean}`;
      } else {
        const freqMap = {};
        values.forEach(value => freqMap[value] = (freqMap[value] || 0) + 1);
        return `Frekuensi: ${Object.entries(freqMap).map(([k, v]) => `${k}: ${v}`).join(', ')}`;
      }
    }

    function getCategoryColor(value, categories) {
      const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A1FF33', '#33FFF0'];
      const index = categories.indexOf(value);
      return colors[index % colors.length];
    }

    function updateLegend(categories, data, column) {
      const freqMap = {};
      data.forEach(row => {
        const value = row[column];
        freqMap[value] = (freqMap[value] || 0) + 1;
      });
      const total = data.length;

      if (legendControl) map.removeControl(legendControl);

      legendControl = L.control({ position: 'bottomright' });
      legendControl.onAdd = function () {
        const div = L.DomUtil.create('div', 'info legend bg-white p-2 rounded shadow');
        div.innerHTML = '<strong>Legenda:</strong><br>';
        categories.forEach(category => {
          const color = getCategoryColor(category, categories);
          const count = freqMap[category] || 0;
          const percentage = ((count / total) * 100).toFixed(1);
          div.innerHTML += `<i style="background:${color}; width:12px; height:12px; display:inline-block; margin-right:8px; border-radius:50%;"></i>${category} ${count} (${percentage}%)<br>`;
        });
        return div;
      };
      legendControl.addTo(map);
    }

    function updateInterpretation(data, column) {
      const freqMap = {};
      data.forEach(row => {
        const value = row[column];
        freqMap[value] = (freqMap[value] || 0) + 1;
      });
      const total = data.length;
      const sorted = Object.entries(freqMap).sort((a, b) => b[1] - a[1]);
      const summary = sorted.map(([cat, count]) => {
        const p = ((count / total) * 100).toFixed(1);
        return `${count} wilayah (${p}%) termasuk dalam kategori "<strong>${cat}</strong>"`;
      });
      const sentence = `Berdasarkan data yang tersedia, dari total ${total} wilayah, ${summary.join(', ').replace(/, ([^,]*)$/, ', dan $1')}.`;
      const maxCat = sorted[0][0];
      const conclusion = `Temuan ini menunjukkan bahwa sebagian besar wilayah berada dalam kategori "<strong>${maxCat}</strong>".`;
      document.getElementById('interpretation').innerHTML = `<p>${sentence}</p><p>${conclusion}</p>`;
    }

    function updateMapWithColor(column) {
      map.eachLayer(layer => {
        if (layer instanceof L.CircleMarker) map.removeLayer(layer);
      });

      const categories = [...new Set(parsedData.map(row => row[column]))];
      const bounds = [];

      parsedData.forEach(row => {
        const lat = parseFloat(row[latKey]);
        const lon = parseFloat(row[lonKey]);
        if (!isNaN(lat) && !isNaN(lon)) {
          const marker = L.circleMarker([lat, lon], {
            radius: 5,
            fillColor: getCategoryColor(row[column], categories),
            color: "#fff",
            weight: 1,
            opacity: 1,
            fillOpacity: 0.85
          }).bindPopup(`${column}: ${row[column]}<br>Lat: ${lat}, Lon: ${lon}`).addTo(map);
          bounds.push([lat, lon]);
        }
      });

      if (bounds.length > 0) {
        map.fitBounds(bounds, { padding: [20, 20] });
        document.getElementById('status').textContent = "Titik berhasil ditampilkan.";
      }

      updateLegend(categories, parsedData, column);
      updateInterpretation(parsedData, column);
    }

    document.getElementById('csvFile').addEventListener('change', function (event) {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('status').textContent = "Memproses file...";
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          const headers = results.meta.fields;
          const detected = detectLatLonFields(headers);
          if (!detected.latKey || !detected.lonKey) {
            document.getElementById('status').textContent = "Kolom latitude/longitude tidak ditemukan.";
            return;
          }
          latKey = detected.latKey;
          lonKey = detected.lonKey;
          parsedData = results.data.filter(row => {
            const lat = parseFloat(row[latKey]);
            const lon = parseFloat(row[lonKey]);
            return !isNaN(lat) && !isNaN(lon);
          });

          if (parsedData.length > 0) {
            document.getElementById('showMapBtn').disabled = false;
            document.getElementById('status').textContent = `Berhasil memuat ${parsedData.length} titik.`;
            const columns = headers.filter(col => col !== latKey && col !== lonKey);
            const select = document.getElementById('columnSelect');
            select.innerHTML = '<option value="" disabled selected>Pilih Kolom untuk Interpretasi</option>';
            columns.forEach(col => {
              const opt = document.createElement('option');
              opt.value = col;
              opt.textContent = col;
              select.appendChild(opt);
            });
            document.getElementById('interpretationSection').style.display = 'block';
          } else {
            document.getElementById('status').textContent = "Tidak ada titik valid ditemukan.";
          }
        }
      });
    });

    document.getElementById('showMapBtn').addEventListener('click', function () {
      const col = document.getElementById('columnSelect').value;
      if (col) updateMapWithColor(col);
    });

    document.getElementById('columnSelect').addEventListener('change', function () {
      selectedColumn = this.value;
      const summary = analyzeColumn(parsedData, selectedColumn);
      document.getElementById('summary').textContent = summary;
    });
  </script>
</body>

<footer class="text-sm text-center mt-8 text-gray-600">
  &copy; 2025 Pavio. Seluruh hak cipta dilindungi.
</footer>
</html>
